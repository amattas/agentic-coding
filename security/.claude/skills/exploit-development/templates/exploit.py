#!/usr/bin/env python3
"""
CTF Exploit Template
Challenge: [CHALLENGE NAME]
Category: Binary Exploitation
"""
from pwn import *

# Configuration
context.arch = 'amd64'  # or 'i386'
context.os = 'linux'
# context.log_level = 'debug'

EXECUTABLE = "./target"
HOST = "localhost"
PORT = 9999

# =============================================================================
# STACK CONSISTENCY - CRITICAL FOR RELIABLE EXPLOITS
# =============================================================================
# The stack layout changes based on:
#   1. Environment variables (each var pushes data onto stack)
#   2. argv[0] length (the program name/path)
#
# Problem: Running "./target" vs "python exploit.py" vs in GDB all give
# different argv[0] values = different stack addresses = inconsistent debugging.
#
# Solution: ALWAYS use a fixed argv[0] and empty environment.
# This ensures your stack is IDENTICAL every time you run locally.
#
# For remote: If your exploit needs absolute stack addresses, you'll need to
# either leak them or match the remote's argv[0] (check Dockerfile).
# If you only use code addresses (ROP, ret2win), this doesn't matter for remote.
# =============================================================================

# Fixed argv[0] for consistent stack layout
# Use a short, fixed path - the actual value doesn't matter, just be consistent
ARGV0 = "/pwn"

# Empty environment - no shell variables polluting the stack
ENV = {}

def conn():
    """
    Connection handler with consistent stack layout.

    Usage:
        python3 exploit.py          # Local with fixed stack
        python3 exploit.py GDB      # Debug with fixed stack (same addresses!)
        python3 exploit.py REMOTE   # Remote server
    """
    if args.REMOTE:
        return remote(HOST, PORT)
    elif args.GDB:
        return gdb.debug(
            [EXECUTABLE],
            env=ENV,
            argv=[ARGV0],  # Fixed argv[0] = consistent stack
            gdbscript='''
                b *main
                c
            '''
        )
    else:
        return process(
            [EXECUTABLE],
            env=ENV,
            argv=[ARGV0]  # Fixed argv[0] = consistent stack
        )

# Main exploit
def main():
    p = conn()

    # ELF setup
    elf = ELF(EXECUTABLE)
    # libc = ELF('./libc.so.6')

    # Key addresses
    # main = elf.symbols['main']
    # win = elf.symbols['win']

    # Gadgets (from ropper)
    # pop_rdi = 0x401234
    # ret = 0x40101a

    # Offsets
    offset = 72  # TODO: Find actual offset

    # Build payload
    payload = b'A' * offset
    # payload += p64(ret)        # Stack alignment (16-byte for x86-64)
    # payload += p64(pop_rdi)
    # payload += p64(arg)
    # payload += p64(win)

    # Send payload
    p.sendlineafter(b'> ', payload)

    # Get flag
    p.interactive()

if __name__ == '__main__':
    main()
